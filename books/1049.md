# 传输层

6.1.1 传输层的作用

从通信和信息处理的角度看，运输层向应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 



![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191203081001.png)

6.1.2 传输层的功能

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191203081109.png)



传输层的主要功能

（1）传输层为应用**进程之间**提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）。

（2）传输层还要对收到的报文进行**差错检测。**

（3）传输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。

> tcp打电话两边连接一起通才行，udp写信给别人，可能地址已经变了，就寄不到了

传输层向上提供可靠的和不可靠的逻辑通信信道

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191203081520.png)

## 6.2 TCP／IP的传输层

### 6.2.1 TCP与UDP

TCP/IP 的传输层有两个不同的协议

（1）**用户数据报协议** UDP（User Datagram Protocol）

（2）**传输控制协议** TCP（Transmission Control Protocol）

两个对等运输实体在通信时传送的数据单位叫作**运输协议数据单元 TPDU** (Transport Protocol Data Unit)。

> 往上都是协议加pdu

TCP 传送的数据单位协议是 TCP 报文段(segment) 

UDP 传送的数据单位协议是 UDP 报文或用户数据报。

UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。

> 是否发出只能依赖应用层，而不是下面层
>
> 网络通畅情况下，效率较高

TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使TCP报文的首部增大很多，还要占用许多的处理机资源。  

运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，但 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。

> 不论是tcp还是udp数据报，最终下一步还是要封装为ip数据报

TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器（分层屏蔽了下层功能），而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。 







### 6.2.2 传输层的端口



从操作系统的角度来看，运行在计算机中的应用进程是用进程标识符来标识的。但传输层的实体却无法使用进程标识符来标识应用进程。

为了使运行不同操作系统的计算机的应用进程能够互相通信，必须用统一的方法对 TCP/IP 体系的应用进程进行标识。解决方法就是在传输层使用协议端口号(protocol port number)，或通常简称为端口(port)

> 比如mysql端口是3306

端口就是运输层服务访问点 TSAP。

端口的作用就是让应用层的各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。

> 端口被占用，要求更换端口
>
> 不是真的端口，数据报中的一个数据体现

从这个意义上讲，端口是用来标志应用层的进程。 

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191203084030.png)



端口在进程之间的通信中所起的作用 

>  安装不需要端口号，默认或者系统分配

端口用一个 16 bit 端口号进行标志。

端口号只具有本地意义，即端口号只是为了**标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。**

> 到达运输层才有端口作用



三类端口 

熟知端口 (well-known port)。其数值一般为 0~1023。这一类端口由ICANN负责分配给一些常用的应用层程序固定使用。

> 早期的，如http，80,20,21

记端口。数值一般为 1024~49151，由ICANN负责登记，防止重复。

> 3306mysql

动态端口。49152-65535，临时端口。

> 每次使用都是变化的



TCP/IP应用层的一些通用服务协议使用的端口

| 服务                          | 端口 | 协议               |
| ----------------------------- | ---- | ------------------ |
| 文件传输服务                  | 21   | FTP                |
| 远程登录服务                  | 23   | TELNET             |
| 传输邮件服务                  | 25   | SMTP（邮件客户端） |
| 用于万维网(WWW)的文本传输服务 | 80   | HTTP               |
| 访问远程服务器上的邮件服务    | 110  | POP3               |
| 互联网消息存取服务            | 143  | IMAP4              |
| 安全的超文本传输服务          | 443  | HTTPS              |
| 安全的远程登录服务            | 992  | TELNETS            |
| 安全的消息存取服务            | 993  | IMAPS              |

> 可以自定义，上面是默认

端口是用报文队列来实现 

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191203090415.png)

TCP 把连接作为最基本的抽象。

每一条 TCP 连接有两个端点。

TCP 连接的端点叫做套接字(socket)或插口。

端口号拼接到(contatenated with) IP 地址即构成了套接字。

每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。

```
TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)} 
```





## 6.3 传输控制协议TCP

6.3.1 TCP协议概述

TCP 是面向连接的运输层协议。采用面向报文段的通信机制

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191203090806.png)

> 存储转发

TCP的主要特点 

TCP 是**面向连接**的运输层协议。每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是**点对点**的（一对一）。 TCP 提供可靠交付的服务。 TCP 提供**全双工**通信。**面向字节流**。  

TCP 面向字节流的概念 

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191203091302.png)



TCP 连接是一条虚连接而不是一条真正的物理连接。

TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。

TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。

TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 







### 6.3.2 TCP报文的格式

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191203092003.png)

在指定进程间进行通信









6.3.3 TCP连接的建立与释放



TCP的连接有三个阶段，即：连接建立、数据传送和连接释放。





1. TCP连接的建立

TCP连接建立过程中要解决以下三个问题：

（1）要使每一方能够确知对方的存在。（2）要允许双方协商一些参数（如最大报文段长度、最大窗口大小、服务质量等）。（3）能够对实体资源（如缓存大小、连接表中的项目等）进行分配。 



客户服务器方式 

TCP 连接的建立都是采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)。被动等待连接建立的应用进程叫做服务器(server)。 



A 必须等待 2MSL 的时间

第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。

第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。





6.3.4 TCP可靠传输的实现

1.理想条件下的可靠传输

理想条件下的可靠传输必须满足两个假定：

①传输信道无差错，所传输的数据既不出错，也不丢失。

②接收方缓存容量无限大。不管发送方以多快的速度发送数据，接收方总是来得及接收和处理收到的数据。



![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210081847.png)

理想条件下的可靠传输



2.简单的停止等待协议

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210082020.png)

通过使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)。

ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。



停止等待协议的优点是简单，但缺点是信道利用率太低

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210082213.png)









信道的利用率 U      （6-1）

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210082319.png)















3.流水线传输



为了提高传输效率，发送方可以采用流水线传输

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210082424.png)

发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。

由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 



累积确认

在流水线传输过程中，接收方采用一种累积确认的方式。即不必对收到的每个报文都发送确认，而是对按序到达的最后一个报文发送一次确认，这样表示到当前报文为止的所有报文都已经正确收到了。



累积确认的优点是：容易实现，即使确认报文丢失也不必重传。

> 后面的还要确认，相当于连前面一起确认了

缺点是：不能向发送方反映出接收方已经正确收到的所有报文的信息。

实际上流水线传输也是在理想条件下实现的可靠传输，实际的网络要考虑各种复杂情况，就要使用连续ARQ协议和滑动窗口协议



4.基于滑动窗口的连续ARQ协议



（1）滑动窗口的概念

TCP采用**大小可变**（根据流量和网络状况判断）的滑动窗口进行流量控制。窗口大小的单位是字节。

在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限。

发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况随时动态地调整对方的发送窗口上限值（可增大或减小）。

TCP滑动窗口用来暂存两台计算机间要传送的数据分组。

每台运行TCP协议的计算机有两个滑动窗口：一个用于数据发送，另一个用于数据接收。

发送端待发数据分组在缓冲区排队等待送出。被滑动窗口框入的分组，是可以在未收到接收确认的情况下最多送出的部分。

滑动窗口左端的分组，是已经被接收端确认收到的分组。随着新的确认到来，窗口不断向右滑动。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210083705.png)





滑动窗口的运行机制

①发送方和接收方都具有一定容量的缓冲区（即窗口），允许发送方连续发送多个报文而不需要等待应答。

②发送窗口就是发送端允许连续发送的TCP报文的序号表，用来对发送端进行流量控制。发送窗口的大小 WS 代表在还没有收到对方确认信息的情况下发送端最多可以连续发送的TCP报文数。

> 已发送未确认

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210084338.png)



③接收窗口是接收方允许接收的报文的序号表，凡落在接收窗口内的TCP报文，接收方都必须处理。接收方每次允许接收的TCP报文数称为接收窗口的大小。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210085731.png)

滑动窗口的关键

发送窗口的大小受接收窗口的控制，即$W_S≤W_R$

（2）基于滑动窗口的可靠传输的实现

```
TCP连接的每一端都必须设有两个窗口：一个发送窗口和一个接收窗口。
TCP 的可靠传输机制用字节的序号进行控制。
TCP 所有的确认都是基于序号而不是基于报文段。
TCP 两端的四个窗口经常处于动态变化之中。
```



![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210090151.png)

根据 B 给出的窗口值A 构造出自己的发送窗口 

TCP 标准强烈不赞成发送窗口前沿向后收缩 

> 已发送数据被后缩，确认时信息是确认哪一个





发送缓存与接收缓存的作用

```
发送缓存用来暂时存放：
 发送应用程序传送给发送方 TCP 准备发送的数据；
 TCP 已发送出但尚未收到确认的数据。
接收缓存用来暂时存放：
 按序到达的、但尚未被接收应用程序读取的数据；
 不按序到达的数据。 

```

需要强调三点

```
A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。
TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。  

```





（3）超时重传时间的选择

重传机制是 TCP 中最重要和最复杂的问题之一。

TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。

由于 TCP 的下层是一个因特网环境，IP 数据报所选择的路由变化很大，因而传输层的往返时延的方差也很大。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191210092149.png)

往返时延的方差很大





加权平均往返时间

TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）。第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS： 新的 RTTS  (1  )  (旧的 RTTS)                          (新的 RTT 样本)                     (6-2)式中，0    1。若  很接近于零，表示 RTT 值更新较慢。若选择  接近于 1，则表示 RTT 值更新较快。RFC 2988 推荐的  值为 1/8，即 0.125。 

























































































































































































































